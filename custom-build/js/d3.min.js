!function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports) : "function" == typeof define && define.amd ? define([ "exports" ], factory) : factory(global.d3 = global.d3 || {});
}(this, function(exports) {
    "use strict";
    function namespace(name) {
        var prefix = name += "", i = prefix.indexOf(":");
        return i >= 0 && "xmlns" !== (prefix = name.slice(0, i)) && (name = name.slice(i + 1)), 
        namespaces.hasOwnProperty(prefix) ? {
            space: namespaces[prefix],
            local: name
        } : name;
    }
    function creatorInherit(name) {
        return function() {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
        };
    }
    function creatorFixed(fullname) {
        return function() {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator(name) {
        var fullname = namespace(name);
        return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
    function filterContextListener(listener, index, group) {
        return listener = contextListener(listener, index, group), function(event) {
            var related = event.relatedTarget;
            related && (related === this || 8 & related.compareDocumentPosition(this)) || listener.call(this, event);
        };
    }
    function contextListener(listener, index, group) {
        return function(event1) {
            var event0 = exports.event;
            exports.event = event1;
            try {
                listener.call(this, this.__data__, index, group);
            } finally {
                exports.event = event0;
            }
        };
    }
    function parseTypenames(typenames) {
        return typenames.trim().split(/^|\s+/).map(function(t) {
            var name = "", i = t.indexOf(".");
            return i >= 0 && (name = t.slice(i + 1), t = t.slice(0, i)), {
                type: t,
                name: name
            };
        });
    }
    function onRemove(typename) {
        return function() {
            var on = this.__on;
            if (on) {
                for (var o, j = 0, i = -1, m = on.length; j < m; ++j) o = on[j], typename.type && o.type !== typename.type || o.name !== typename.name ? on[++i] = o : this.removeEventListener(o.type, o.listener, o.capture);
                ++i ? on.length = i : delete this.__on;
            }
        };
    }
    function onAdd(typename, value, capture) {
        var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
        return function(d, i, group) {
            var o, on = this.__on, listener = wrap(value, i, group);
            if (on) for (var j = 0, m = on.length; j < m; ++j) if ((o = on[j]).type === typename.type && o.name === typename.name) return this.removeEventListener(o.type, o.listener, o.capture), 
            this.addEventListener(o.type, o.listener = listener, o.capture = capture), void (o.value = value);
            this.addEventListener(typename.type, listener, capture), o = {
                type: typename.type,
                name: typename.name,
                value: value,
                listener: listener,
                capture: capture
            }, on ? on.push(o) : this.__on = [ o ];
        };
    }
    function selection_on(typename, value, capture) {
        var i, t, typenames = parseTypenames(typename + ""), n = typenames.length;
        {
            if (!(arguments.length < 2)) {
                for (on = value ? onAdd : onRemove, null == capture && (capture = !1), i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
                return this;
            }
            var on = this.node().__on;
            if (on) for (var o, j = 0, m = on.length; j < m; ++j) for (i = 0, o = on[j]; i < n; ++i) if ((t = typenames[i]).type === o.type && t.name === o.name) return o.value;
        }
    }
    function selector(selector) {
        return function() {
            return this.querySelector(selector);
        };
    }
    function selection_select(select) {
        "function" != typeof select && (select = selector(select));
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) for (var node, subnode, group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), i = 0; i < n; ++i) (node = group[i]) && (subnode = select.call(node, node.__data__, i, group)) && ("__data__" in node && (subnode.__data__ = node.__data__), 
        subgroup[i] = subnode);
        return new Selection(subgroups, this._parents);
    }
    function selectorAll(selector) {
        return function() {
            return this.querySelectorAll(selector);
        };
    }
    function selection_selectAll(select) {
        "function" != typeof select && (select = selectorAll(select));
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) for (var node, group = groups[j], n = group.length, i = 0; i < n; ++i) (node = group[i]) && (subgroups.push(select.call(node, node.__data__, i, group)), 
        parents.push(node));
        return new Selection(subgroups, parents);
    }
    function selection_filter(match) {
        "function" != typeof match && (match = matcher$1(match));
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) for (var node, group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), i = 0; i < n; ++i) (node = group[i]) && match.call(node, node.__data__, i, group) && (subgroup[i] = node);
        return new Selection(subgroups, this._parents);
    }
    function constant(x) {
        return function() {
            return x;
        };
    }
    function bindIndex(parent, group, enter, update, exit, data) {
        for (var node, i = 0, groupLength = group.length, dataLength = data.length; i < dataLength; ++i) (node = group[i]) ? (node.__data__ = data[i], 
        update[i] = node) : enter[i] = new EnterNode(parent, data[i]);
        for (;i < groupLength; ++i) (node = group[i]) && (exit[i] = node);
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
        var i, node, keyValue, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength);
        for (i = 0; i < groupLength; ++i) (node = group[i]) && (keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group), 
        keyValue in nodeByKeyValue ? exit[i] = node : nodeByKeyValue[keyValue] = node);
        for (i = 0; i < dataLength; ++i) keyValue = keyPrefix + key.call(parent, data[i], i, data), 
        (node = nodeByKeyValue[keyValue]) ? (update[i] = node, node.__data__ = data[i], 
        nodeByKeyValue[keyValue] = null) : enter[i] = new EnterNode(parent, data[i]);
        for (i = 0; i < groupLength; ++i) (node = group[i]) && nodeByKeyValue[keyValues[i]] === node && (exit[i] = node);
    }
    function selection_data(value, key) {
        if (!value) return data = new Array(this.size()), j = -1, this.each(function(d) {
            data[++j] = d;
        }), data;
        var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
        "function" != typeof value && (value = constant(value));
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            for (var previous, next, i0 = 0, i1 = 0; i0 < dataLength; ++i0) if (previous = enterGroup[i0]) {
                for (i0 >= i1 && (i1 = i0 + 1); !(next = updateGroup[i1]) && ++i1 < dataLength; ) ;
                previous._next = next || null;
            }
        }
        return update = new Selection(update, parents), update._enter = enter, update._exit = exit, 
        update;
    }
    function EnterNode(parent, datum) {
        this.ownerDocument = parent.ownerDocument, this.namespaceURI = parent.namespaceURI, 
        this._next = null, this._parent = parent, this.__data__ = datum;
    }
    function sparse(update) {
        return new Array(update.length);
    }
    function selection_enter() {
        return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }
    function selection_exit() {
        return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }
    function selection_merge(selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) for (var node, group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), i = 0; i < n; ++i) (node = group0[i] || group1[i]) && (merge[i] = node);
        for (;j < m0; ++j) merges[j] = groups0[j];
        return new Selection(merges, this._parents);
    }
    function selection_order() {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) for (var node, group = groups[j], i = group.length - 1, next = group[i]; --i >= 0; ) (node = group[i]) && (next && next !== node.nextSibling && next.parentNode.insertBefore(node, next), 
        next = node);
        return this;
    }
    function selection_sort(compare) {
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        compare || (compare = ascending);
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var node, group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), i = 0; i < n; ++i) (node = group[i]) && (sortgroup[i] = node);
            sortgroup.sort(compareNode);
        }
        return new Selection(sortgroups, this._parents).order();
    }
    function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function selection_call() {
        var callback = arguments[0];
        return arguments[0] = this, callback.apply(null, arguments), this;
    }
    function selection_nodes() {
        var nodes = new Array(this.size()), i = -1;
        return this.each(function() {
            nodes[++i] = this;
        }), nodes;
    }
    function selection_node() {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
            var node = group[i];
            if (node) return node;
        }
        return null;
    }
    function selection_size() {
        var size = 0;
        return this.each(function() {
            ++size;
        }), size;
    }
    function selection_empty() {
        return !this.node();
    }
    function selection_each(callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) for (var node, group = groups[j], i = 0, n = group.length; i < n; ++i) (node = group[i]) && callback.call(node, node.__data__, i, group);
        return this;
    }
    function attrRemove(name) {
        return function() {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS(fullname) {
        return function() {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant(name, value) {
        return function() {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS(fullname, value) {
        return function() {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction(name, value) {
        return function() {
            var v = value.apply(this, arguments);
            null == v ? this.removeAttribute(name) : this.setAttribute(name, v);
        };
    }
    function attrFunctionNS(fullname, value) {
        return function() {
            var v = value.apply(this, arguments);
            null == v ? this.removeAttributeNS(fullname.space, fullname.local) : this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr(name, value) {
        var fullname = namespace(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
        }
        return this.each((null == value ? fullname.local ? attrRemoveNS : attrRemove : "function" == typeof value ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
    }
    function defaultView(node) {
        return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
    }
    function styleRemove(name) {
        return function() {
            this.style.removeProperty(name);
        };
    }
    function styleConstant(name, value, priority) {
        return function() {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction(name, value, priority) {
        return function() {
            var v = value.apply(this, arguments);
            null == v ? this.style.removeProperty(name) : this.style.setProperty(name, v, priority);
        };
    }
    function selection_style(name, value, priority) {
        var node;
        return arguments.length > 1 ? this.each((null == value ? styleRemove : "function" == typeof value ? styleFunction : styleConstant)(name, value, null == priority ? "" : priority)) : defaultView(node = this.node()).getComputedStyle(node, null).getPropertyValue(name);
    }
    function propertyRemove(name) {
        return function() {
            delete this[name];
        };
    }
    function propertyConstant(name, value) {
        return function() {
            this[name] = value;
        };
    }
    function propertyFunction(name, value) {
        return function() {
            var v = value.apply(this, arguments);
            null == v ? delete this[name] : this[name] = v;
        };
    }
    function selection_property(name, value) {
        return arguments.length > 1 ? this.each((null == value ? propertyRemove : "function" == typeof value ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }
    function classArray(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList(node) {
        return node.classList || new ClassList(node);
    }
    function ClassList(node) {
        this._node = node, this._names = classArray(node.getAttribute("class") || "");
    }
    function classedAdd(node, names) {
        for (var list = classList(node), i = -1, n = names.length; ++i < n; ) list.add(names[i]);
    }
    function classedRemove(node, names) {
        for (var list = classList(node), i = -1, n = names.length; ++i < n; ) list.remove(names[i]);
    }
    function classedTrue(names) {
        return function() {
            classedAdd(this, names);
        };
    }
    function classedFalse(names) {
        return function() {
            classedRemove(this, names);
        };
    }
    function classedFunction(names, value) {
        return function() {
            (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
    }
    function selection_classed(name, value) {
        var names = classArray(name + "");
        if (arguments.length < 2) {
            for (var list = classList(this.node()), i = -1, n = names.length; ++i < n; ) if (!list.contains(names[i])) return !1;
            return !0;
        }
        return this.each(("function" == typeof value ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }
    function textRemove() {
        this.textContent = "";
    }
    function textConstant(value) {
        return function() {
            this.textContent = value;
        };
    }
    function textFunction(value) {
        return function() {
            var v = value.apply(this, arguments);
            this.textContent = null == v ? "" : v;
        };
    }
    function selection_text(value) {
        return arguments.length ? this.each(null == value ? textRemove : ("function" == typeof value ? textFunction : textConstant)(value)) : this.node().textContent;
    }
    function htmlRemove() {
        this.innerHTML = "";
    }
    function htmlConstant(value) {
        return function() {
            this.innerHTML = value;
        };
    }
    function htmlFunction(value) {
        return function() {
            var v = value.apply(this, arguments);
            this.innerHTML = null == v ? "" : v;
        };
    }
    function selection_html(value) {
        return arguments.length ? this.each(null == value ? htmlRemove : ("function" == typeof value ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }
    function raise() {
        this.nextSibling && this.parentNode.appendChild(this);
    }
    function selection_raise() {
        return this.each(raise);
    }
    function lower() {
        this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower() {
        return this.each(lower);
    }
    function append(create) {
        return function() {
            return this.appendChild(create.apply(this, arguments));
        };
    }
    function insert(create, select) {
        return function() {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        };
    }
    function constantNull() {
        return null;
    }
    function selection_append(name, before) {
        var create = "function" == typeof name ? name : creator(name);
        return this.select(arguments.length < 2 ? append(create) : insert(create, null == before ? constantNull : "function" == typeof before ? before : selector(before)));
    }
    function remove() {
        var parent = this.parentNode;
        parent && parent.removeChild(this);
    }
    function selection_remove() {
        return this.each(remove);
    }
    function selection_datum(value) {
        return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
    function dispatchEvent(node, type, params) {
        var window = defaultView(node), event = window.CustomEvent;
        event ? event = new event(type, params) : (event = window.document.createEvent("Event"), 
        params ? (event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail) : event.initEvent(type, !1, !1)), 
        node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
        return function() {
            return dispatchEvent(this, type, params);
        };
    }
    function dispatchFunction(type, params) {
        return function() {
            return dispatchEvent(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch(type, params) {
        return this.each(("function" == typeof params ? dispatchFunction : dispatchConstant)(type, params));
    }
    function Selection(groups, parents) {
        this._groups = groups, this._parents = parents;
    }
    function selection() {
        return new Selection([ [ document.documentElement ] ], root);
    }
    function select(selector) {
        return "string" == typeof selector ? new Selection([ [ document.querySelector(selector) ] ], [ document.documentElement ]) : new Selection([ [ selector ] ], root);
    }
    function selectAll(selector) {
        return "string" == typeof selector ? new Selection([ document.querySelectorAll(selector) ], [ document.documentElement ]) : new Selection([ selector ], root);
    }
    function adder() {
        return new Adder();
    }
    function Adder() {
        this.reset();
    }
    function add(adder, a, b) {
        var x = adder.s = a + b, bv = x - a, av = x - bv;
        adder.t = a - av + (b - bv);
    }
    function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }
    function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }
    function haversin(x) {
        return (x = sin(x / 2)) * x;
    }
    function noop() {}
    function streamGeometry(geometry, stream) {
        geometry && streamGeometryType.hasOwnProperty(geometry.type) && streamGeometryType[geometry.type](geometry, stream);
    }
    function streamLine(coordinates, stream, closed) {
        var coordinate, i = -1, n = coordinates.length - closed;
        for (stream.lineStart(); ++i < n; ) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
    }
    function streamPolygon(coordinates, stream) {
        var i = -1, n = coordinates.length;
        for (stream.polygonStart(); ++i < n; ) streamLine(coordinates[i], stream, 1);
        stream.polygonEnd();
    }
    function geoStream(object, stream) {
        object && streamObjectType.hasOwnProperty(object.type) ? streamObjectType[object.type](object, stream) : streamGeometry(object, stream);
    }
    function areaRingStart() {
        areaStream.point = areaPointFirst;
    }
    function areaRingEnd() {
        areaPoint(lambda00, phi00);
    }
    function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint, lambda00 = lambda, phi00 = phi, lambda *= radians, 
        phi *= radians, lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
    }
    function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians, phi = phi / 2 + quarterPi;
        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
        areaRingSum.add(atan2(v, u)), lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
    }
    function area(object) {
        return areaSum.reset(), geoStream(object, areaStream), 2 * areaSum;
    }
    function spherical(cartesian) {
        return [ atan2(cartesian[1], cartesian[0]), asin(cartesian[2]) ];
    }
    function cartesian(spherical) {
        var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
        return [ cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi) ];
    }
    function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function cartesianCross(a, b) {
        return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }
    function cartesianScale(vector, k) {
        return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function cartesianNormalizeInPlace(d) {
        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l;
    }
    function boundsPoint(lambda, phi) {
        ranges.push(range = [ lambda0$1 = lambda, lambda1 = lambda ]), phi < phi0 && (phi0 = phi), 
        phi > phi1 && (phi1 = phi);
    }
    function linePoint(lambda, phi) {
        var p = cartesian([ lambda * radians, phi * radians ]);
        if (p0) {
            var normal = cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = cartesianCross(equatorial, normal);
            cartesianNormalizeInPlace(inflection), inflection = spherical(inflection);
            var phii, delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign, antimeridian = abs(delta) > 180;
            antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda) ? (phii = inflection[1] * degrees, 
            phii > phi1 && (phi1 = phii)) : (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda) ? (phii = -inflection[1] * degrees, 
            phii < phi0 && (phi0 = phii)) : (phi < phi0 && (phi0 = phi), phi > phi1 && (phi1 = phi))), 
            antimeridian ? lambda < lambda2 ? angle(lambda0$1, lambda) > angle(lambda0$1, lambda1) && (lambda1 = lambda) : angle(lambda, lambda1) > angle(lambda0$1, lambda1) && (lambda0$1 = lambda) : lambda1 >= lambda0$1 ? (lambda < lambda0$1 && (lambda0$1 = lambda), 
            lambda > lambda1 && (lambda1 = lambda)) : lambda > lambda2 ? angle(lambda0$1, lambda) > angle(lambda0$1, lambda1) && (lambda1 = lambda) : angle(lambda, lambda1) > angle(lambda0$1, lambda1) && (lambda0$1 = lambda);
        } else boundsPoint(lambda, phi);
        p0 = p, lambda2 = lambda;
    }
    function boundsLineStart() {
        boundsStream.point = linePoint;
    }
    function boundsLineEnd() {
        range[0] = lambda0$1, range[1] = lambda1, boundsStream.point = boundsPoint, p0 = null;
    }
    function boundsRingPoint(lambda, phi) {
        if (p0) {
            var delta = lambda - lambda2;
            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        } else lambda00$1 = lambda, phi00$1 = phi;
        areaStream.point(lambda, phi), linePoint(lambda, phi);
    }
    function boundsRingStart() {
        areaStream.lineStart();
    }
    function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1), areaStream.lineEnd(), abs(deltaSum) > epsilon && (lambda0$1 = -(lambda1 = 180)), 
        range[0] = lambda0$1, range[1] = lambda1, p0 = null;
    }
    function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }
    function rangeCompare(a, b) {
        return a[0] - b[0];
    }
    function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    function bounds(feature) {
        var i, n, a, b, merged, deltaMax, delta;
        if (phi1 = lambda1 = -(lambda0$1 = phi0 = 1 / 0), ranges = [], geoStream(feature, boundsStream), 
        n = ranges.length) {
            for (ranges.sort(rangeCompare), i = 1, a = ranges[0], merged = [ a ]; i < n; ++i) b = ranges[i], 
            rangeContains(a, b[0]) || rangeContains(a, b[1]) ? (angle(a[0], b[1]) > angle(a[0], a[1]) && (a[1] = b[1]), 
            angle(b[0], a[1]) > angle(a[0], a[1]) && (a[0] = b[0])) : merged.push(a = b);
            for (deltaMax = -(1 / 0), n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, 
            ++i) b = merged[i], (delta = angle(a[1], b[0])) > deltaMax && (deltaMax = delta, 
            lambda0$1 = b[0], lambda1 = a[1]);
        }
        return ranges = range = null, lambda0$1 === 1 / 0 || phi0 === 1 / 0 ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ lambda0$1, phi0 ], [ lambda1, phi1 ] ];
    }
    function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
    }
    function centroidPointCartesian(x, y, z) {
        ++W0, X0 += (x - X0) / W0, Y0 += (y - Y0) / W0, Z0 += (z - Z0) / W0;
    }
    function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
    }
    function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda), y0 = cosPhi * sin(lambda), z0 = sin(phi), centroidStream.point = centroidLinePoint, 
        centroidPointCartesian(x0, y0, z0);
    }
    function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        W1 += w, X1 += w * (x0 + (x0 = x)), Y1 += w * (y0 + (y0 = y)), Z1 += w * (z0 + (z0 = z)), 
        centroidPointCartesian(x0, y0, z0);
    }
    function centroidLineEnd() {
        centroidStream.point = centroidPoint;
    }
    function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
    }
    function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2), centroidStream.point = centroidPoint;
    }
    function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi, lambda *= radians, phi *= radians, centroidStream.point = centroidRingPoint;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda), y0 = cosPhi * sin(lambda), z0 = sin(phi), centroidPointCartesian(x0, y0, z0);
    }
    function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -acos(u) / m, w = atan2(m, u);
        X2 += v * cx, Y2 += v * cy, Z2 += v * cz, W1 += w, X1 += w * (x0 + (x0 = x)), Y1 += w * (y0 + (y0 = y)), 
        Z1 += w * (z0 + (z0 = z)), centroidPointCartesian(x0, y0, z0);
    }
    function centroid(object) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0, geoStream(object, centroidStream);
        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
        return m < epsilon2 && (x = X1, y = Y1, z = Z1, W1 < epsilon && (x = X0, y = Y0, 
        z = Z0), m = x * x + y * y + z * z, m < epsilon2) ? [ NaN, NaN ] : [ atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees ];
    }
    function constant$1(x) {
        return function() {
            return x;
        };
    }
    function compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        return a.invert && b.invert && (compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        }), compose;
    }
    function rotationIdentity(lambda, phi) {
        return [ lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi ];
    }
    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
    }
    function forwardRotationLambda(deltaLambda) {
        return function(lambda, phi) {
            return lambda += deltaLambda, [ lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi ];
        };
    }
    function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda);
        return rotation.invert = forwardRotationLambda(-deltaLambda), rotation;
    }
    function rotationPhiGamma(deltaPhi, deltaGamma) {
        function rotation(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
            return [ atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma) ];
        }
        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
        return rotation.invert = function(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
            return [ atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi) ];
        }, rotation;
    }
    function rotation(rotate) {
        function forward(coordinates) {
            return coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians), 
            coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
        }
        return rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0), 
        forward.invert = function(coordinates) {
            return coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians), 
            coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
        }, forward;
    }
    function circleStream(stream, radius, delta, direction, t0, t1) {
        if (delta) {
            var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
            null == t0 ? (t0 = radius + direction * tau, t1 = radius - step / 2) : (t0 = circleRadius(cosRadius, t0), 
            t1 = circleRadius(cosRadius, t1), (direction > 0 ? t0 < t1 : t0 > t1) && (t0 += direction * tau));
            for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) point = spherical([ cosRadius, -sinRadius * cos(t), -sinRadius * sin(t) ]), 
            stream.point(point[0], point[1]);
        }
    }
    function circleRadius(cosRadius, point) {
        point = cartesian(point), point[0] -= cosRadius, cartesianNormalizeInPlace(point);
        var radius = acos(-point[1]);
        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
    }
    function circle() {
        function point(x, y) {
            ring.push(x = rotate(x, y)), x[0] *= degrees, x[1] *= degrees;
        }
        function circle() {
            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
            return ring = [], rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert, 
            circleStream(stream, r, p, 1), c = {
                type: "Polygon",
                coordinates: [ ring ]
            }, ring = rotate = null, c;
        }
        var ring, rotate, center = constant$1([ 0, 0 ]), radius = constant$1(90), precision = constant$1(6), stream = {
            point: point
        };
        return circle.center = function(_) {
            return arguments.length ? (center = "function" == typeof _ ? _ : constant$1([ +_[0], +_[1] ]), 
            circle) : center;
        }, circle.radius = function(_) {
            return arguments.length ? (radius = "function" == typeof _ ? _ : constant$1(+_), 
            circle) : radius;
        }, circle.precision = function(_) {
            return arguments.length ? (precision = "function" == typeof _ ? _ : constant$1(+_), 
            circle) : precision;
        }, circle;
    }
    function clipBuffer() {
        var line, lines = [];
        return {
            point: function(x, y) {
                line.push([ x, y ]);
            },
            lineStart: function() {
                lines.push(line = []);
            },
            lineEnd: noop,
            rejoin: function() {
                lines.length > 1 && lines.push(lines.pop().concat(lines.shift()));
            },
            result: function() {
                var result = lines;
                return lines = [], line = null, result;
            }
        };
    }
    function clipLine(a, b, x0, y0, x1, y1) {
        var r, ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay;
        if (r = x0 - ax, dx || !(r > 0)) {
            if (r /= dx, dx < 0) {
                if (r < t0) return;
                r < t1 && (t1 = r);
            } else if (dx > 0) {
                if (r > t1) return;
                r > t0 && (t0 = r);
            }
            if (r = x1 - ax, dx || !(r < 0)) {
                if (r /= dx, dx < 0) {
                    if (r > t1) return;
                    r > t0 && (t0 = r);
                } else if (dx > 0) {
                    if (r < t0) return;
                    r < t1 && (t1 = r);
                }
                if (r = y0 - ay, dy || !(r > 0)) {
                    if (r /= dy, dy < 0) {
                        if (r < t0) return;
                        r < t1 && (t1 = r);
                    } else if (dy > 0) {
                        if (r > t1) return;
                        r > t0 && (t0 = r);
                    }
                    if (r = y1 - ay, dy || !(r < 0)) {
                        if (r /= dy, dy < 0) {
                            if (r > t1) return;
                            r > t0 && (t0 = r);
                        } else if (dy > 0) {
                            if (r < t0) return;
                            r < t1 && (t1 = r);
                        }
                        return t0 > 0 && (a[0] = ax + t0 * dx, a[1] = ay + t0 * dy), t1 < 1 && (b[0] = ax + t1 * dx, 
                        b[1] = ay + t1 * dy), !0;
                    }
                }
            }
        }
    }
    function pointEqual(a, b) {
        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
    }
    function Intersection(point, points, other, entry) {
        this.x = point, this.z = points, this.o = other, this.e = entry, this.v = !1, this.n = this.p = null;
    }
    function clipPolygon(segments, compareIntersection, startInside, interpolate, stream) {
        var i, n, subject = [], clip = [];
        if (segments.forEach(function(segment) {
            if (!((n = segment.length - 1) <= 0)) {
                var n, x, p0 = segment[0], p1 = segment[n];
                if (pointEqual(p0, p1)) {
                    for (stream.lineStart(), i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
                    return void stream.lineEnd();
                }
                subject.push(x = new Intersection(p0, segment, null, !0)), clip.push(x.o = new Intersection(p0, null, x, !1)), 
                subject.push(x = new Intersection(p1, segment, null, !1)), clip.push(x.o = new Intersection(p1, null, x, !0));
            }
        }), subject.length) {
            for (clip.sort(compareIntersection), link(subject), link(clip), i = 0, n = clip.length; i < n; ++i) clip[i].e = startInside = !startInside;
            for (var points, point, start = subject[0]; ;) {
                for (var current = start, isSubject = !0; current.v; ) if ((current = current.n) === start) return;
                points = current.z, stream.lineStart();
                do {
                    if (current.v = current.o.v = !0, current.e) {
                        if (isSubject) for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]); else interpolate(current.x, current.n.x, 1, stream);
                        current = current.n;
                    } else {
                        if (isSubject) for (points = current.p.z, i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]); else interpolate(current.x, current.p.x, -1, stream);
                        current = current.p;
                    }
                    current = current.o, points = current.z, isSubject = !isSubject;
                } while (!current.v);
                stream.lineEnd();
            }
        }
    }
    function link(array) {
        if (n = array.length) {
            for (var n, b, i = 0, a = array[0]; ++i < n; ) a.n = b = array[i], b.p = a, a = b;
            a.n = b = array[0], b.p = a;
        }
    }
    function ascending$1(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function bisector(compare) {
        return 1 === compare.length && (compare = ascendingComparator(compare)), {
            left: function(a, x, lo, hi) {
                for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                    var mid = lo + hi >>> 1;
                    compare(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                    var mid = lo + hi >>> 1;
                    compare(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
                }
                return lo;
            }
        };
    }
    function ascendingComparator(f) {
        return function(d, x) {
            return ascending$1(f(d), x);
        };
    }
    function range$1(start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, 
        start = 0, 1) : n < 3 ? 1 : +step;
        for (var i = -1, n = 0 | Math.max(0, Math.ceil((stop - start) / step)), range = new Array(n); ++i < n; ) range[i] = start + i * step;
        return range;
    }
    function merge(arrays) {
        for (var m, merged, array, n = arrays.length, i = -1, j = 0; ++i < n; ) j += arrays[i].length;
        for (merged = new Array(j); --n >= 0; ) for (array = arrays[n], m = array.length; --m >= 0; ) merged[--j] = array[m];
        return merged;
    }
    function clipExtent(x0, y0, x1, y1) {
        function visible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
        }
        function interpolate(from, to, direction, stream) {
            var a = 0, a1 = 0;
            if (null == from || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
                do stream.point(0 === a || 3 === a ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
            } else stream.point(to[0], to[1]);
        }
        function corner(p, direction) {
            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compareIntersection(a, b) {
            return comparePoint(a.x, b.x);
        }
        function comparePoint(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : 0 === ca ? b[1] - a[1] : 1 === ca ? a[0] - b[0] : 2 === ca ? a[1] - b[1] : b[0] - a[0];
        }
        return function(stream) {
            function point(x, y) {
                visible(x, y) && activeStream.point(x, y);
            }
            function polygonInside() {
                for (var winding = 0, i = 0, n = polygon.length; i < n; ++i) for (var a0, a1, ring = polygon[i], j = 1, m = ring.length, point = ring[0], b0 = point[0], b1 = point[1]; j < m; ++j) a0 = b0, 
                a1 = b1, point = ring[j], b0 = point[0], b1 = point[1], a1 <= y1 ? b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0) && ++winding : b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0) && --winding;
                return winding;
            }
            function polygonStart() {
                activeStream = bufferStream, segments = [], polygon = [], clean = !0;
            }
            function polygonEnd() {
                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = merge(segments)).length;
                (cleanInside || visible) && (stream.polygonStart(), cleanInside && (stream.lineStart(), 
                interpolate(null, null, 1, stream), stream.lineEnd()), visible && clipPolygon(segments, compareIntersection, startInside, interpolate, stream), 
                stream.polygonEnd()), activeStream = stream, segments = polygon = ring = null;
            }
            function lineStart() {
                clipStream.point = linePoint, polygon && polygon.push(ring = []), first = !0, v_ = !1, 
                x_ = y_ = NaN;
            }
            function lineEnd() {
                segments && (linePoint(x__, y__), v__ && v_ && bufferStream.rejoin(), segments.push(bufferStream.result())), 
                clipStream.point = point, v_ && activeStream.lineEnd();
            }
            function linePoint(x, y) {
                var v = visible(x, y);
                if (polygon && ring.push([ x, y ]), first) x__ = x, y__ = y, v__ = v, first = !1, 
                v && (activeStream.lineStart(), activeStream.point(x, y)); else if (v && v_) activeStream.point(x, y); else {
                    var a = [ x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_)) ], b = [ x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y)) ];
                    clipLine(a, b, x0, y0, x1, y1) ? (v_ || (activeStream.lineStart(), activeStream.point(a[0], a[1])), 
                    activeStream.point(b[0], b[1]), v || activeStream.lineEnd(), clean = !1) : v && (activeStream.lineStart(), 
                    activeStream.point(x, y), clean = !1);
                }
                x_ = x, y_ = y, v_ = v;
            }
            var segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean, activeStream = stream, bufferStream = clipBuffer(), clipStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: polygonStart,
                polygonEnd: polygonEnd
            };
            return clipStream;
        };
    }
    function extent() {
        var cache, cacheStream, clip, x0 = 0, y0 = 0, x1 = 960, y1 = 500;
        return clip = {
            stream: function(stream) {
                return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
            },
            extent: function(_) {
                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], 
                cache = cacheStream = null, clip) : [ [ x0, y0 ], [ x1, y1 ] ];
            }
        };
    }
    function lengthLineStart() {
        lengthStream.point = lengthPointFirst, lengthStream.lineEnd = lengthLineEnd;
    }
    function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop;
    }
    function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians, lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi), 
        lengthStream.point = lengthPoint;
    }
    function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt(x * x + y * y), z)), lambda0$2 = lambda, sinPhi0$1 = sinPhi, 
        cosPhi0$1 = cosPhi;
    }
    function length$1(object) {
        return lengthSum.reset(), geoStream(object, lengthStream), +lengthSum;
    }
    function distance(a, b) {
        return coordinates[0] = a, coordinates[1] = b, length$1(object);
    }
    function graticuleX(y0, y1, dy) {
        var y = range$1(y0, y1 - epsilon, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [ x, y ];
            });
        };
    }
    function graticuleY(x0, x1, dx) {
        var x = range$1(x0, x1 - epsilon, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [ x, y ];
            });
        };
    }
    function graticule() {
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return range$1(ceil(X0 / DX) * DX, X1, DX).map(X).concat(range$1(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(range$1(ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > epsilon;
            }).map(x)).concat(range$1(ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > epsilon;
            }).map(y));
        }
        var x1, x0, X1, X0, y1, y0, Y1, Y0, x, y, X, Y, dx = 10, dy = dx, DX = 90, DY = 360, precision = 2.5;
        return graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        }, graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
            };
        }, graticule.extent = function(_) {
            return arguments.length ? graticule.extentMajor(_).extentMinor(_) : graticule.extentMinor();
        }, graticule.extentMajor = function(_) {
            return arguments.length ? (X0 = +_[0][0], X1 = +_[1][0], Y0 = +_[0][1], Y1 = +_[1][1], 
            X0 > X1 && (_ = X0, X0 = X1, X1 = _), Y0 > Y1 && (_ = Y0, Y0 = Y1, Y1 = _), graticule.precision(precision)) : [ [ X0, Y0 ], [ X1, Y1 ] ];
        }, graticule.extentMinor = function(_) {
            return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], 
            x0 > x1 && (_ = x0, x0 = x1, x1 = _), y0 > y1 && (_ = y0, y0 = y1, y1 = _), graticule.precision(precision)) : [ [ x0, y0 ], [ x1, y1 ] ];
        }, graticule.step = function(_) {
            return arguments.length ? graticule.stepMajor(_).stepMinor(_) : graticule.stepMinor();
        }, graticule.stepMajor = function(_) {
            return arguments.length ? (DX = +_[0], DY = +_[1], graticule) : [ DX, DY ];
        }, graticule.stepMinor = function(_) {
            return arguments.length ? (dx = +_[0], dy = +_[1], graticule) : [ dx, dy ];
        }, graticule.precision = function(_) {
            return arguments.length ? (precision = +_, x = graticuleX(y0, y1, 90), y = graticuleY(x0, x1, precision), 
            X = graticuleX(Y0, Y1, 90), Y = graticuleY(X0, X1, precision), graticule) : precision;
        }, graticule.extentMajor([ [ -180, -90 + epsilon ], [ 180, 90 - epsilon ] ]).extentMinor([ [ -180, -80 - epsilon ], [ 180, 80 + epsilon ] ]);
    }
    function interpolate(a, b) {
        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos(y0), sy0 = sin(y0), cy1 = cos(y1), sy1 = sin(y1), kx0 = cy0 * cos(x0), ky0 = cy0 * sin(x0), kx1 = cy1 * cos(x1), ky1 = cy1 * sin(x1), d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin(d), interpolate = d ? function(t) {
            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [ atan2(y, x) * degrees, atan2(z, sqrt(x * x + y * y)) * degrees ];
        } : function() {
            return [ x0 * degrees, y0 * degrees ];
        };
        return interpolate.distance = d, interpolate;
    }
    function identity$1(x) {
        return x;
    }
    function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
    }
    function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1, x00 = x0$1 = x, y00 = y0$1 = y;
    }
    function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y), x0$1 = x, y0$1 = y;
    }
    function areaRingEnd$1() {
        areaPoint$1(x00, y00);
    }
    function boundsPoint$1(x, y) {
        x < x0$2 && (x0$2 = x), x > x1 && (x1 = x), y < y0$2 && (y0$2 = y), y > y1 && (y1 = y);
    }
    function centroidPoint$1(x, y) {
        X0$1 += x, Y0$1 += y, ++Z0$1;
    }
    function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
    }
    function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine, centroidPoint$1(x0$3 = x, y0$3 = y);
    }
    function centroidPointLine(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2, Y1$1 += z * (y0$3 + y) / 2, Z1$1 += z, centroidPoint$1(x0$3 = x, y0$3 = y);
    }
    function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
    }
    function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
    }
    function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
    }
    function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing, centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
    }
    function centroidPointRing(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2, Y1$1 += z * (y0$3 + y) / 2, Z1$1 += z, z = y0$3 * x - x0$3 * y, 
        X2$1 += z * (x0$3 + x), Y2$1 += z * (y0$3 + y), Z2$1 += 3 * z, centroidPoint$1(x0$3 = x, y0$3 = y);
    }
    function PathContext(context) {
        this._context = context;
    }
    function PathString() {
        this._string = [];
    }
    function circle$1(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    function index() {
        function path(object) {
            return object && ("function" == typeof pointRadius && contextStream.pointRadius(+pointRadius.apply(this, arguments)), 
            geoStream(object, projectionStream(contextStream))), contextStream.result();
        }
        var projection, projectionStream, context, contextStream, pointRadius = 4.5;
        return path.area = function(object) {
            return geoStream(object, projectionStream(areaStream$1)), areaStream$1.result();
        }, path.bounds = function(object) {
            return geoStream(object, projectionStream(boundsStream$1)), boundsStream$1.result();
        }, path.centroid = function(object) {
            return geoStream(object, projectionStream(centroidStream$1)), centroidStream$1.result();
        }, path.projection = function(_) {
            return arguments.length ? (projectionStream = null == (projection = _) ? identity$1 : _.stream, 
            path) : projection;
        }, path.context = function(_) {
            return arguments.length ? (contextStream = null == (context = _) ? new PathString() : new PathContext(_), 
            "function" != typeof pointRadius && contextStream.pointRadius(pointRadius), path) : context;
        }, path.pointRadius = function(_) {
            return arguments.length ? (pointRadius = "function" == typeof _ ? _ : (contextStream.pointRadius(+_), 
            +_), path) : pointRadius;
        }, path.projection(null).context(null);
    }
    function polygonContains(polygon, point) {
        var lambda = point[0], phi = point[1], normal = [ sin(lambda), -cos(lambda), 0 ], angle = 0, winding = 0;
        sum$1.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) if (m = (ring = polygon[i]).length) for (var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0), j = 0; j < m; ++j, 
        lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
            var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
            if (sum$1.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta))), 
            angle += antimeridian ? delta + sign * tau : delta, antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
                var arc = cartesianCross(cartesian(point0), cartesian(point1));
                cartesianNormalizeInPlace(arc);
                var intersection = cartesianCross(normal, arc);
                cartesianNormalizeInPlace(intersection);
                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) && (winding += antimeridian ^ delta >= 0 ? 1 : -1);
            }
        }
        return (angle < -epsilon || angle < epsilon && sum$1 < -epsilon) ^ 1 & winding;
    }
    function clip(pointVisible, clipLine, interpolate, start) {
        return function(rotate, sink) {
            function point(lambda, phi) {
                var point = rotate(lambda, phi);
                pointVisible(lambda = point[0], phi = point[1]) && sink.point(lambda, phi);
            }
            function pointLine(lambda, phi) {
                var point = rotate(lambda, phi);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine, line.lineStart();
            }
            function lineEnd() {
                clip.point = point, line.lineEnd();
            }
            function pointRing(lambda, phi) {
                ring.push([ lambda, phi ]);
                var point = rotate(lambda, phi);
                ringSink.point(point[0], point[1]);
            }
            function ringStart() {
                ringSink.lineStart(), ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]), ringSink.lineEnd();
                var i, m, segment, point, clean = ringSink.clean(), ringSegments = ringBuffer.result(), n = ringSegments.length;
                if (ring.pop(), polygon.push(ring), ring = null, n) if (1 & clean) {
                    if (segment = ringSegments[0], (m = segment.length - 1) > 0) {
                        for (polygonStarted || (sink.polygonStart(), polygonStarted = !0), sink.lineStart(), 
                        i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
                        sink.lineEnd();
                    }
                } else n > 1 && 2 & clean && ringSegments.push(ringSegments.pop().concat(ringSegments.shift())), 
                segments.push(ringSegments.filter(validSegment));
            }
            var polygon, segments, ring, line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = !1, clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing, clip.lineStart = ringStart, clip.lineEnd = ringEnd, segments = [], 
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point, clip.lineStart = lineStart, clip.lineEnd = lineEnd, segments = merge(segments);
                    var startInside = polygonContains(polygon, rotatedStart);
                    segments.length ? (polygonStarted || (sink.polygonStart(), polygonStarted = !0), 
                    clipPolygon(segments, compareIntersection, startInside, interpolate, sink)) : startInside && (polygonStarted || (sink.polygonStart(), 
                    polygonStarted = !0), sink.lineStart(), interpolate(null, null, 1, sink), sink.lineEnd()), 
                    polygonStarted && (sink.polygonEnd(), polygonStarted = !1), segments = polygon = null;
                },
                sphere: function() {
                    sink.polygonStart(), sink.lineStart(), interpolate(null, null, 1, sink), sink.lineEnd(), 
                    sink.polygonEnd();
                }
            };
            return clip;
        };
    }
    function validSegment(segment) {
        return segment.length > 1;
    }
    function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
    }
    function clipAntimeridianLine(stream) {
        var clean, lambda0 = NaN, phi0 = NaN, sign0 = NaN;
        return {
            lineStart: function() {
                stream.lineStart(), clean = 1;
            },
            point: function(lambda1, phi1) {
                var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
                abs(delta - pi) < epsilon ? (stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi), 
                stream.point(sign0, phi0), stream.lineEnd(), stream.lineStart(), stream.point(sign1, phi0), 
                stream.point(lambda1, phi0), clean = 0) : sign0 !== sign1 && delta >= pi && (abs(lambda0 - sign0) < epsilon && (lambda0 -= sign0 * epsilon), 
                abs(lambda1 - sign1) < epsilon && (lambda1 -= sign1 * epsilon), phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1), 
                stream.point(sign0, phi0), stream.lineEnd(), stream.lineStart(), stream.point(sign1, phi0), 
                clean = 0), stream.point(lambda0 = lambda1, phi0 = phi1), sign0 = sign1;
            },
            lineEnd: function() {
                stream.lineEnd(), lambda0 = phi0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
        return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
    }
    function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (null == from) phi = direction * halfPi, stream.point(-pi, phi), stream.point(0, phi), 
        stream.point(pi, phi), stream.point(pi, 0), stream.point(pi, -phi), stream.point(0, -phi), 
        stream.point(-pi, -phi), stream.point(-pi, 0), stream.point(-pi, phi); else if (abs(from[0] - to[0]) > epsilon) {
            var lambda = from[0] < to[0] ? pi : -pi;
            phi = direction * lambda / 2, stream.point(-lambda, phi), stream.point(0, phi), 
            stream.point(lambda, phi);
        } else stream.point(to[0], to[1]);
    }
    function clipCircle(radius, delta) {
        function interpolate(from, to, direction, stream) {
            circleStream(stream, radius, delta, direction, from, to);
        }
        function visible(lambda, phi) {
            return cos(lambda) * cos(phi) > cr;
        }
        function clipLine(stream) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = !1, clean = 1;
                },
                point: function(lambda, phi) {
                    var point2, point1 = [ lambda, phi ], v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                    if (!point0 && (v00 = v0 = v) && stream.lineStart(), v !== v0 && (point2 = intersect(point0, point1), 
                    (pointEqual(point0, point2) || pointEqual(point1, point2)) && (point1[0] += epsilon, 
                    point1[1] += epsilon, v = visible(point1[0], point1[1]))), v !== v0) clean = 0, 
                    v ? (stream.lineStart(), point2 = intersect(point1, point0), stream.point(point2[0], point2[1])) : (point2 = intersect(point0, point1), 
                    stream.point(point2[0], point2[1]), stream.lineEnd()), point0 = point2; else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        c & c0 || !(t = intersect(point1, point0, !0)) || (clean = 0, smallRadius ? (stream.lineStart(), 
                        stream.point(t[0][0], t[0][1]), stream.point(t[1][0], t[1][1]), stream.lineEnd()) : (stream.point(t[1][0], t[1][1]), 
                        stream.lineEnd(), stream.lineStart(), stream.point(t[0][0], t[0][1])));
                    }
                    !v || point0 && pointEqual(point0, point1) || stream.point(point1[0], point1[1]), 
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    v0 && stream.lineEnd(), point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = cartesian(a), pb = cartesian(b), n1 = [ 1, 0, 0 ], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
            cartesianAddInPlace(A, B);
            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
            if (!(t2 < 0)) {
                var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
                if (cartesianAddInPlace(q, A), q = spherical(q), !two) return q;
                var z, lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1];
                lambda1 < lambda0 && (z = lambda0, lambda0 = lambda1, lambda1 = z);
                var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;
                if (!polar && phi1 < phi0 && (z = phi0, phi0 = phi1, phi1 = z), meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
                    var q1 = cartesianScale(u, (-w + t) / uu);
                    return cartesianAddInPlace(q1, A), [ q, spherical(q1) ];
                }
            }
        }
        function code(lambda, phi) {
            var r = smallRadius ? radius : pi - radius, code = 0;
            return lambda < -r ? code |= 1 : lambda > r && (code |= 2), phi < -r ? code |= 4 : phi > r && (code |= 8), 
            code;
        }
        var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
        return clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -pi, radius - pi ]);
    }
    function transform(prototype) {
        return {
            stream: transform$1(prototype)
        };
    }
    function transform$1(prototype) {
        function T() {}
        var p = T.prototype = Object.create(Transform.prototype);
        for (var k in prototype) p[k] = prototype[k];
        return function(stream) {
            var t = new T();
            return t.stream = stream, t;
        };
    }
    function Transform() {}
    function fit(project, extent, object) {
        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = project.clipExtent && project.clipExtent();
        project.scale(150).translate([ 0, 0 ]), null != clip && project.clipExtent(null), 
        geoStream(object, project.stream(boundsStream$1));
        var b = boundsStream$1.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        return null != clip && project.clipExtent(clip), project.scale(150 * k).translate([ x, y ]);
    }
    function fitSize(project) {
        return function(size, object) {
            return fit(project, [ [ 0, 0 ], size ], object);
        };
    }
    function fitExtent(project) {
        return function(extent, object) {
            return fit(project, extent, object);
        };
    }
    function resample(project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }
    function resampleNone(project) {
        return transform$1({
            point: function(x, y) {
                x = project(x, y), this.stream.point(x[0], x[1]);
            }
        });
    }
    function resample$1(project, delta2) {
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) && (resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream), 
                stream.point(x2, y2), resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream));
            }
        }
        return function(stream) {
            function point(x, y) {
                x = project(x, y), stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN, resampleStream.point = linePoint, stream.lineStart();
            }
            function linePoint(lambda, phi) {
                var c = cartesian([ lambda, phi ]), p = project(lambda, phi);
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream), 
                stream.point(x0, y0);
            }
            function lineEnd() {
                resampleStream.point = point, stream.lineEnd();
            }
            function ringStart() {
                lineStart(), resampleStream.point = ringPoint, resampleStream.lineEnd = ringEnd;
            }
            function ringPoint(lambda, phi) {
                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0, 
                resampleStream.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream), 
                resampleStream.lineEnd = lineEnd, lineEnd();
            }
            var lambda00, x00, y00, a00, b00, c00, lambda0, x0, y0, a0, b0, c0, resampleStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart(), resampleStream.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd(), resampleStream.lineStart = lineStart;
                }
            };
            return resampleStream;
        };
    }
    function projection(project) {
        return projectionMutator(function() {
            return project;
        })();
    }
    function projectionMutator(projectAt) {
        function projection(point) {
            return point = projectRotate(point[0] * radians, point[1] * radians), [ point[0] * k + dx, dy - point[1] * k ];
        }
        function invert(point) {
            return point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k), point && [ point[0] * degrees, point[1] * degrees ];
        }
        function projectTransform(x, y) {
            return x = project(x, y), [ x[0] * k + dx, dy - x[1] * k ];
        }
        function recenter() {
            projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
            var center = project(lambda, phi);
            return dx = x - center[0] * k, dy = y + center[1] * k, reset();
        }
        function reset() {
            return cache = cacheStream = null, projection;
        }
        var project, dx, dy, rotate, projectRotate, y0, x1, y1, cache, cacheStream, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, theta = null, preclip = clipAntimeridian, x0 = null, postclip = identity$1, delta2 = .5, projectResample = resample(projectTransform, delta2);
        return projection.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
        }, projection.clipAngle = function(_) {
            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, 
            clipAntimeridian), reset()) : theta * degrees;
        }, projection.clipExtent = function(_) {
            return arguments.length ? (postclip = null == _ ? (x0 = y0 = x1 = y1 = null, identity$1) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), 
            reset()) : null == x0 ? null : [ [ x0, y0 ], [ x1, y1 ] ];
        }, projection.scale = function(_) {
            return arguments.length ? (k = +_, recenter()) : k;
        }, projection.translate = function(_) {
            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [ x, y ];
        }, projection.center = function(_) {
            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, 
            recenter()) : [ lambda * degrees, phi * degrees ];
        }, projection.rotate = function(_) {
            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, 
            deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [ deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees ];
        }, projection.precision = function(_) {
            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), 
            reset()) : sqrt(delta2);
        }, projection.fitExtent = fitExtent(projection), projection.fitSize = fitSize(projection), 
        function() {
            return project = projectAt.apply(this, arguments), projection.invert = project.invert && invert, 
            recenter();
        };
    }
    function conicProjection(projectAt) {
        var phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);
        return p.parallels = function(_) {
            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [ phi0 * degrees, phi1 * degrees ];
        }, p;
    }
    function conicEqualAreaRaw(y0, y1) {
        function project(x, y) {
            var r = sqrt(c - 2 * n * sin(y)) / n;
            return [ r * sin(x *= n), r0 - r * cos(x) ];
        }
        var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2, c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
        return project.invert = function(x, y) {
            var r0y = r0 - y;
            return [ atan2(x, r0y) / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n)) ];
        }, project;
    }
    function conicEqualArea() {
        return conicProjection(conicEqualAreaRaw).scale(155.424).center([ 0, 33.6442 ]);
    }
    function albers() {
        return conicEqualArea().parallels([ 29.5, 45.5 ]).scale(1070).translate([ 480, 250 ]).rotate([ 96, 0 ]).center([ -.6, 38.7 ]);
    }
    function multiplex(streams) {
        var n = streams.length;
        return {
            point: function(x, y) {
                for (var i = -1; ++i < n; ) streams[i].point(x, y);
            },
            sphere: function() {
                for (var i = -1; ++i < n; ) streams[i].sphere();
            },
            lineStart: function() {
                for (var i = -1; ++i < n; ) streams[i].lineStart();
            },
            lineEnd: function() {
                for (var i = -1; ++i < n; ) streams[i].lineEnd();
            },
            polygonStart: function() {
                for (var i = -1; ++i < n; ) streams[i].polygonStart();
            },
            polygonEnd: function() {
                for (var i = -1; ++i < n; ) streams[i].polygonEnd();
            }
        };
    }
    function albersUsa() {
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            return point = null, lower48Point.point(x, y), point || (alaskaPoint.point(x, y), 
            point) || (hawaiiPoint.point(x, y), point);
        }
        function reset() {
            return cache = cacheStream = null, albersUsa;
        }
        var cache, cacheStream, lower48Point, alaskaPoint, hawaiiPoint, point, lower48 = albers(), alaska = conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]), hawaii = conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]), pointStream = {
            point: function(x, y) {
                point = [ x, y ];
            }
        };
        return albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        }, albersUsa.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([ lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream) ]);
        }, albersUsa.precision = function(_) {
            return arguments.length ? (lower48.precision(_), alaska.precision(_), hawaii.precision(_), 
            reset()) : lower48.precision();
        }, albersUsa.scale = function(_) {
            return arguments.length ? (lower48.scale(_), alaska.scale(.35 * _), hawaii.scale(_), 
            albersUsa.translate(lower48.translate())) : lower48.scale();
        }, albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            return lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream), 
            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + epsilon, y + .12 * k + epsilon ], [ x - .214 * k - epsilon, y + .234 * k - epsilon ] ]).stream(pointStream), 
            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + epsilon, y + .166 * k + epsilon ], [ x - .115 * k - epsilon, y + .234 * k - epsilon ] ]).stream(pointStream), 
            reset();
        }, albersUsa.fitExtent = fitExtent(albersUsa), albersUsa.fitSize = fitSize(albersUsa), 
        albersUsa.scale(1070);
    }
    function azimuthalRaw(scale) {
        return function(x, y) {
            var cx = cos(x), cy = cos(y), k = scale(cx * cy);
            return [ k * cy * sin(x), k * sin(y) ];
        };
    }
    function azimuthalInvert(angle) {
        return function(x, y) {
            var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);
            return [ atan2(x * sc, z * cc), asin(z && y * sc / z) ];
        };
    }
    function azimuthalEqualArea() {
        return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(179.999);
    }
    function azimuthalEquidistant() {
        return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(179.999);
    }
    function mercatorRaw(lambda, phi) {
        return [ lambda, log(tan((halfPi + phi) / 2)) ];
    }
    function mercator() {
        return mercatorProjection(mercatorRaw).scale(961 / tau);
    }
    function mercatorProjection(project) {
        var clipAuto, m = projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent;
        return m.scale = function(_) {
            return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();
        }, m.translate = function(_) {
            return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();
        }, m.clipExtent = function(_) {
            if (!arguments.length) return clipAuto ? null : clipExtent();
            if (clipAuto = null == _) {
                var k = pi * scale(), t = translate();
                _ = [ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ];
            }
            return clipExtent(_), m;
        }, m.clipExtent(null);
    }
    function tany(y) {
        return tan((halfPi + y) / 2);
    }
    function conicConformalRaw(y0, y1) {
        function project(x, y) {
            f > 0 ? y < -halfPi + epsilon && (y = -halfPi + epsilon) : y > halfPi - epsilon && (y = halfPi - epsilon);
            var r = f / pow(tany(y), n);
            return [ r * sin(n * x), f - r * cos(n * x) ];
        }
        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow(tany(y0), n) / n;
        return n ? (project.invert = function(x, y) {
            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
            return [ atan2(x, fy) / n, 2 * atan(pow(f / r, 1 / n)) - halfPi ];
        }, project) : mercatorRaw;
    }
    function conicConformal() {
        return conicProjection(conicConformalRaw).scale(109.5).parallels([ 30, 30 ]);
    }
    function equirectangularRaw(lambda, phi) {
        return [ lambda, phi ];
    }
    function equirectangular() {
        return projection(equirectangularRaw).scale(152.63);
    }
    function conicEquidistantRaw(y0, y1) {
        function project(x, y) {
            var gy = g - y, nx = n * x;
            return [ gy * sin(nx), g - gy * cos(nx) ];
        }
        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0), g = cy0 / n + y0;
        return abs(n) < epsilon ? equirectangularRaw : (project.invert = function(x, y) {
            var gy = g - y;
            return [ atan2(x, gy) / n, g - sign(n) * sqrt(x * x + gy * gy) ];
        }, project);
    }
    function conicEquidistant() {
        return conicProjection(conicEquidistantRaw).scale(131.154).center([ 0, 13.9389 ]);
    }
    function gnomonicRaw(x, y) {
        var cy = cos(y), k = cos(x) * cy;
        return [ cy * sin(x) / k, sin(y) / k ];
    }
    function gnomonic() {
        return projection(gnomonicRaw).scale(144.049).clipAngle(60);
    }
    function orthographicRaw(x, y) {
        return [ cos(y) * sin(x), sin(y) ];
    }
    function orthographic() {
        return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
    }
    function stereographicRaw(x, y) {
        var cy = cos(y), k = 1 + cos(x) * cy;
        return [ cy * sin(x) / k, sin(y) / k ];
    }
    function stereographic() {
        return projection(stereographicRaw).scale(250).clipAngle(142);
    }
    function transverseMercatorRaw(lambda, phi) {
        return [ log(tan((halfPi + phi) / 2)), -lambda ];
    }
    function transverseMercator() {
        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
        return m.center = function(_) {
            return arguments.length ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
        }, m.rotate = function(_) {
            return arguments.length ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
            [ _[0], _[1], _[2] - 90 ]);
        }, rotate([ 0, 0, 90 ]).scale(159.155);
    }
    var xhtml = "http://www.w3.org/1999/xhtml", namespaces = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    }, matcher = function(selector) {
        return function() {
            return this.matches(selector);
        };
    };
    if ("undefined" != typeof document) {
        var element = document.documentElement;
        if (!element.matches) {
            var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;
            matcher = function(selector) {
                return function() {
                    return vendorMatches.call(this, selector);
                };
            };
        }
    }
    var matcher$1 = matcher, filterEvents = {};
    if (exports.event = null, "undefined" != typeof document) {
        var element$1 = document.documentElement;
        "onmouseenter" in element$1 || (filterEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        });
    }
    var keyPrefix = "$";
    EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function(child) {
            return this._parent.insertBefore(child, this._next);
        },
        insertBefore: function(child, next) {
            return this._parent.insertBefore(child, next);
        },
        querySelector: function(selector) {
            return this._parent.querySelector(selector);
        },
        querySelectorAll: function(selector) {
            return this._parent.querySelectorAll(selector);
        }
    }, ClassList.prototype = {
        add: function(name) {
            var i = this._names.indexOf(name);
            i < 0 && (this._names.push(name), this._node.setAttribute("class", this._names.join(" ")));
        },
        remove: function(name) {
            var i = this._names.indexOf(name);
            i >= 0 && (this._names.splice(i, 1), this._node.setAttribute("class", this._names.join(" ")));
        },
        contains: function(name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    var root = [ null ];
    Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: selection_select,
        selectAll: selection_selectAll,
        filter: selection_filter,
        data: selection_data,
        enter: selection_enter,
        exit: selection_exit,
        merge: selection_merge,
        order: selection_order,
        sort: selection_sort,
        call: selection_call,
        nodes: selection_nodes,
        node: selection_node,
        size: selection_size,
        empty: selection_empty,
        each: selection_each,
        attr: selection_attr,
        style: selection_style,
        property: selection_property,
        classed: selection_classed,
        text: selection_text,
        html: selection_html,
        raise: selection_raise,
        lower: selection_lower,
        append: selection_append,
        remove: selection_remove,
        datum: selection_datum,
        on: selection_on,
        dispatch: selection_dispatch
    }, Adder.prototype = {
        constructor: Adder,
        reset: function() {
            this.s = this.t = 0;
        },
        add: function(y) {
            add(temp, y, this.t), add(this, temp.s, this.s), this.s ? this.t += temp.t : this.s = temp.t;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var lambda00, phi00, lambda0, cosPhi0, sinPhi0, lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, ranges, range, W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0, temp = new Adder(), epsilon = 1e-6, epsilon2 = 1e-12, pi = Math.PI, halfPi = pi / 2, quarterPi = pi / 4, tau = 2 * pi, degrees = 180 / pi, radians = pi / 180, abs = Math.abs, atan = Math.atan, atan2 = Math.atan2, cos = Math.cos, ceil = Math.ceil, exp = Math.exp, log = Math.log, pow = Math.pow, sin = Math.sin, sign = Math.sign || function(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }, sqrt = Math.sqrt, tan = Math.tan, streamObjectType = {
        Feature: function(feature, stream) {
            streamGeometry(feature.geometry, stream);
        },
        FeatureCollection: function(object, stream) {
            for (var features = object.features, i = -1, n = features.length; ++i < n; ) streamGeometry(features[i].geometry, stream);
        }
    }, streamGeometryType = {
        Sphere: function(object, stream) {
            stream.sphere();
        },
        Point: function(object, stream) {
            object = object.coordinates, stream.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, stream) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) object = coordinates[i], 
            stream.point(object[0], object[1], object[2]);
        },
        LineString: function(object, stream) {
            streamLine(object.coordinates, stream, 0);
        },
        MultiLineString: function(object, stream) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) streamLine(coordinates[i], stream, 0);
        },
        Polygon: function(object, stream) {
            streamPolygon(object.coordinates, stream);
        },
        MultiPolygon: function(object, stream) {
            for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) streamPolygon(coordinates[i], stream);
        },
        GeometryCollection: function(object, stream) {
            for (var geometries = object.geometries, i = -1, n = geometries.length; ++i < n; ) streamGeometry(geometries[i], stream);
        }
    }, areaRingSum = adder(), areaSum = adder(), areaStream = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
            areaRingSum.reset(), areaStream.lineStart = areaRingStart, areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function() {
            var areaRing = +areaRingSum;
            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing), this.lineStart = this.lineEnd = this.point = noop;
        },
        sphere: function() {
            areaSum.add(tau);
        }
    }, deltaSum = adder(), boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function() {
            boundsStream.point = boundsRingPoint, boundsStream.lineStart = boundsRingStart, 
            boundsStream.lineEnd = boundsRingEnd, deltaSum.reset(), areaStream.polygonStart();
        },
        polygonEnd: function() {
            areaStream.polygonEnd(), boundsStream.point = boundsPoint, boundsStream.lineStart = boundsLineStart, 
            boundsStream.lineEnd = boundsLineEnd, areaRingSum < 0 ? (lambda0$1 = -(lambda1 = 180), 
            phi0 = -(phi1 = 90)) : deltaSum > epsilon ? phi1 = 90 : deltaSum < -epsilon && (phi0 = -90), 
            range[0] = lambda0$1, range[1] = lambda1;
        }
    }, centroidStream = {
        sphere: noop,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function() {
            centroidStream.lineStart = centroidRingStart, centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function() {
            centroidStream.lineStart = centroidLineStart, centroidStream.lineEnd = centroidLineEnd;
        }
    };
    rotationIdentity.invert = rotationIdentity;
    var lambda0$2, sinPhi0$1, cosPhi0$1, x00, y00, x0$1, y0$1, x00$1, y00$1, x0$3, y0$3, clipMax = (bisector(ascending$1), 
    1e9), clipMin = -clipMax, lengthSum = adder(), lengthStream = {
        sphere: noop,
        point: noop,
        lineStart: lengthLineStart,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop
    }, coordinates = [ null, null ], object = {
        type: "LineString",
        coordinates: coordinates
    }, areaSum$1 = adder(), areaRingSum$1 = adder(), areaStream$1 = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
            areaStream$1.lineStart = areaRingStart$1, areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function() {
            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop, areaSum$1.add(abs(areaRingSum$1)), 
            areaRingSum$1.reset();
        },
        result: function() {
            var area = areaSum$1 / 2;
            return areaSum$1.reset(), area;
        }
    }, x0$2 = 1 / 0, y0$2 = x0$2, x1 = -x0$2, y1 = x1, boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop,
        result: function() {
            var bounds = [ [ x0$2, y0$2 ], [ x1, y1 ] ];
            return x1 = y1 = -(y0$2 = x0$2 = 1 / 0), bounds;
        }
    }, X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function() {
            centroidStream$1.lineStart = centroidRingStart$1, centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function() {
            centroidStream$1.point = centroidPoint$1, centroidStream$1.lineStart = centroidLineStart$1, 
            centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function() {
            var centroid = Z2$1 ? [ X2$1 / Z2$1, Y2$1 / Z2$1 ] : Z1$1 ? [ X1$1 / Z1$1, Y1$1 / Z1$1 ] : Z0$1 ? [ X0$1 / Z0$1, Y0$1 / Z0$1 ] : [ NaN, NaN ];
            return X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0, centroid;
        }
    };
    PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function(_) {
            return this._radius = _, this;
        },
        polygonStart: function() {
            this._line = 0;
        },
        polygonEnd: function() {
            this._line = NaN;
        },
        lineStart: function() {
            this._point = 0;
        },
        lineEnd: function() {
            0 === this._line && this._context.closePath(), this._point = NaN;
        },
        point: function(x, y) {
            switch (this._point) {
              case 0:
                this._context.moveTo(x, y), this._point = 1;
                break;

              case 1:
                this._context.lineTo(x, y);
                break;

              default:
                this._context.moveTo(x + this._radius, y), this._context.arc(x, y, this._radius, 0, tau);
            }
        },
        result: noop
    }, PathString.prototype = {
        _circle: circle$1(4.5),
        pointRadius: function(_) {
            return this._circle = circle$1(_), this;
        },
        polygonStart: function() {
            this._line = 0;
        },
        polygonEnd: function() {
            this._line = NaN;
        },
        lineStart: function() {
            this._point = 0;
        },
        lineEnd: function() {
            0 === this._line && this._string.push("Z"), this._point = NaN;
        },
        point: function(x, y) {
            switch (this._point) {
              case 0:
                this._string.push("M", x, ",", y), this._point = 1;
                break;

              case 1:
                this._string.push("L", x, ",", y);
                break;

              default:
                this._string.push("M", x, ",", y, this._circle);
            }
        },
        result: function() {
            if (this._string.length) {
                var result = this._string.join("");
                return this._string = [], result;
            }
        }
    };
    var sum$1 = adder(), clipAntimeridian = clip(function() {
        return !0;
    }, clipAntimeridianLine, clipAntimeridianInterpolate, [ -pi, -halfPi ]);
    Transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    var maxDepth = 16, cosMinDistance = cos(30 * radians), transformRadians = transform$1({
        point: function(x, y) {
            this.stream.point(x * radians, y * radians);
        }
    }), azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
        return sqrt(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
        return 2 * asin(z / 2);
    });
    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
        return (c = acos(c)) && c / sin(c);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
        return z;
    }), mercatorRaw.invert = function(x, y) {
        return [ x, 2 * atan(exp(y)) - halfPi ];
    }, equirectangularRaw.invert = equirectangularRaw, gnomonicRaw.invert = azimuthalInvert(atan), 
    orthographicRaw.invert = azimuthalInvert(asin), stereographicRaw.invert = azimuthalInvert(function(z) {
        return 2 * atan(z);
    }), transverseMercatorRaw.invert = function(x, y) {
        return [ -y, 2 * atan(exp(x)) - halfPi ];
    }, exports.select = select, exports.selectAll = selectAll, exports.geoArea = area, 
    exports.geoBounds = bounds, exports.geoCentroid = centroid, exports.geoCircle = circle, 
    exports.geoClipExtent = extent, exports.geoDistance = distance, exports.geoGraticule = graticule, 
    exports.geoInterpolate = interpolate, exports.geoLength = length$1, exports.geoPath = index, 
    exports.geoAlbers = albers, exports.geoAlbersUsa = albersUsa, exports.geoAzimuthalEqualArea = azimuthalEqualArea, 
    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw, exports.geoAzimuthalEquidistant = azimuthalEquidistant, 
    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw, exports.geoConicConformal = conicConformal, 
    exports.geoConicConformalRaw = conicConformalRaw, exports.geoConicEqualArea = conicEqualArea, 
    exports.geoConicEqualAreaRaw = conicEqualAreaRaw, exports.geoConicEquidistant = conicEquidistant, 
    exports.geoConicEquidistantRaw = conicEquidistantRaw, exports.geoEquirectangular = equirectangular, 
    exports.geoEquirectangularRaw = equirectangularRaw, exports.geoGnomonic = gnomonic, 
    exports.geoGnomonicRaw = gnomonicRaw, exports.geoProjection = projection, exports.geoProjectionMutator = projectionMutator, 
    exports.geoMercator = mercator, exports.geoMercatorRaw = mercatorRaw, exports.geoOrthographic = orthographic, 
    exports.geoOrthographicRaw = orthographicRaw, exports.geoStereographic = stereographic, 
    exports.geoStereographicRaw = stereographicRaw, exports.geoTransverseMercator = transverseMercator, 
    exports.geoTransverseMercatorRaw = transverseMercatorRaw, exports.geoRotation = rotation, 
    exports.geoStream = geoStream, exports.geoTransform = transform, Object.defineProperty(exports, "__esModule", {
        value: !0
    });
});